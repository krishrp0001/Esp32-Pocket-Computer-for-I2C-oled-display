/*

In this code there are 20 Applications for wifi tools look for another code
in this repo

    "Calculator",

    "Stopwatch",

    "Alarm",

    "Snake",

    "Distance",

    "Temperature",

    "Sunlight",

    "Pong",

    "Wifi Scanner",

    "Notes",

    "Dice Roller",

    "Paint",

    "Unit Convetor",

    "BMI",

    "Timer",

    "SpaceShooter",
    
    "SciCalculator",
    
    "Elements",
    
    "Command Prompt",
    

*/

//cpp
//ESP32 pocket computer 
#include <Wire.h>

 #include <Adafruit_GFX.h>

#include <Adafruit_SSD1306.h>

#include <WiFi.h>

#include <esp_wifi.h>


// Screen dimensions for the OLED display

#define SCREEN_WIDTH 128

#define SCREEN_HEIGHT 64

// Initialize the SSD1306 display object

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);


// ==================== PIN DEFINITIONS & CONFIG ====================

// GPIO pin assignments for joystick, buttons, and sensors

#define JOY_X      34     // Analog pin for Joystick X-axis

#define JOY_Y      35     // Analog pin for Joystick Y-axis

#define JOY_BTN    32     // Digital pin for Joystick button (pull-up)

#define BACK_BTN   33     // Digital pin for Back button (pull-up)

#define TRIG_PIN   25     // Digital pin for Ultrasonic Sensor Trigger

#define ECHO_PIN   26     // Digital pin for Ultrasonic Sensor Echo

#define BUZZER_PIN 27     // Digital pin for Buzzer

#define THERM_PIN  36     // Analog pin for Thermistor (ADC1_CH0)

#define LDR_PIN    39     // Analog pin for Light Dependent Resistor (ADC1_CH3)


// Joystick calibration and navigation settings

#define JOY_CENTER    2048  // Approximate center value for joystick analog read

#define JOY_DEADZONE  500   // Range around center where movement is ignored

#define NAV_DELAY     180   // Milliseconds delay between menu cursor moves


// --- Menu State Variables ---

// Array of strings for menu item names

String menuItems[] = {

    "Calculator",

    "Stopwatch",

    "Alarm",

    "Snake",

    "Distance",

    "Temperature",

    "Sunlight",

    "Pong",

    "Wifi Scanner",

    "Notes",

    "Dice Roller",

    "Paint",

    "Unit Convetor",

    "BMI",

    "Timer",

    "SpaceShooter",
    
    "SciCalculator",
    
    "Elements",
    
    "Command Prompt",

    "..."

};

int totalMenuItems = 20;        // Total number of items in the menu

int currentSelection = 0;       // Index of the currently selected menu item

unsigned long lastMoveTime = 0; // Timestamp of the last menu navigation

bool inApp = false;             // Flag to indicate if an application is currently running


// ==================== FORWARD DECLARATIONS ====================

// Declare all application functions

void runCalculator();

void runStopwatch();

void runAlarm();

void runSnake();

void runDistance();

void runTemperature();

void runSunlight();

void runPong();

void runWifiScanner();

void runNotesApp();

void runDice();

void runPaint();

void runDistanceConverter();

void runBMI();

void runTimer();

void runSpaceShooter();

void runSciCalculator();

void runElements();

void runCommandPrompt();



// ==================== SETUP & MAIN LOOP ====================

void setup() {

    Serial.begin(115200); // Initialize serial communication for debugging

    Wire.begin(21, 22);   // Initialize I2C for OLED display (SDA=21, SCL=22)


    // Set pin modes for buttons and sensors

    pinMode(JOY_BTN, INPUT_PULLUP);

    pinMode(BACK_BTN, INPUT_PULLUP);

    pinMode(LDR_PIN, INPUT); // LDR is an analog input


    analogReadResolution(12); // Set ADC resolution to 12 bits (0-4095)


    // Initialize OLED display

    if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {

        Serial.println(F("SSD1306 allocation failed"));

        for (;;); // Loop indefinitely if display fails to initialize

    }


    // Display a loading message on the OLED

    display.clearDisplay();

    display.setTextSize(1);

    display.setTextColor(SSD1306_WHITE);

    display.setCursor(0, 0);

    display.println("Menu Loading...");

    display.display();

    delay(1000); // Short delay for display

}


void loop() {

    // If not in an application, show the main menu

    if (!inApp) {

        showMenu(); // Display and handle menu navigation

        // Check if joystick button is pressed to select an app

        if (digitalRead(JOY_BTN) == LOW) {

            waitRelease(JOY_BTN); // Wait for button release to avoid multiple presses

            openApp(currentSelection); // Launch the selected application

        }

    }

}


// ==================== MENU & APP LAUNCHER ====================


// Function to display the main menu and handle navigation

void showMenu() {

    int yValue = analogRead(JOY_Y); // Read joystick Y-axis value

    unsigned long currentTime = millis(); // Get current time for debouncing


    // Handle menu navigation based on joystick Y-axis movement

    if (currentTime - lastMoveTime > NAV_DELAY) {

        if (yValue < (JOY_CENTER - JOY_DEADZONE)) { // Joystick moved up

            currentSelection--; // Move selection up

            if (currentSelection < 0) currentSelection = totalMenuItems - 1; // Wrap around to end

            lastMoveTime = currentTime; // Update last move time

        } else if (yValue > (JOY_CENTER + JOY_DEADZONE)) { // Joystick moved down

            currentSelection++; // Move selection down

            if (currentSelection >= totalMenuItems) currentSelection = 0; // Wrap around to beginning

            lastMoveTime = currentTime; // Update last move time

        }

    }


    display.clearDisplay();         // Clear the display buffer

    display.setTextSize(1);         // Set text size (1 is 6x8 pixels)

    display.setTextColor(SSD1306_WHITE); // Set text color to white


    display.setCursor(0, 0);        // Set cursor to top-left

    display.println("ESP32 Menu");  // Print menu title

    display.drawFastHLine(0, 8, SCREEN_WIDTH, SSD1306_WHITE); // Draw a separator line


    const int MAX_ITEMS_ON_SCREEN = 5; // Maximum number of menu items to show at once

    const int LINE_HEIGHT = 12;        // Vertical spacing between menu items


    int startItem = 0; // Index of the first item to display on screen

    // Adjust startItem to ensure the currentSelection is visible

    if (currentSelection >= MAX_ITEMS_ON_SCREEN) {

        startItem = currentSelection - (MAX_ITEMS_ON_SCREEN - 1);

    }

    

    // Loop to draw menu items

    for (int i = startItem; i < startItem + MAX_ITEMS_ON_SCREEN && i < totalMenuItems; i++) {

        int yPos = 12 + (i - startItem) * LINE_HEIGHT; // Calculate Y position for the current item

        

        // Temporarily set text color to white for normal drawing

        display.setTextColor(SSD1306_WHITE);

        display.setCursor(0, yPos);

        display.print("> ");

        display.print(menuItems[i]); // Use print instead of println to allow precise background fill


        // If the current item is selected, draw a highlight rectangle and redraw text in black

        if (i == currentSelection) {

            // Calculate the width of the text to be highlighted

            String itemText = "> " + menuItems[i];

            int textWidth = itemText.length() * 6; // text size 1 (6 pixels wide per character)

            

            // Draw a white filled rectangle over the text area for highlighting

            // Adding a small margin (+2) to the width for better appearance

            display.fillRect(0, yPos, textWidth + 2, LINE_HEIGHT, SSD1306_WHITE);

            display.setTextColor(SSD1306_BLACK); // Set text color to black for selected item

            display.setCursor(0, yPos); // Reset cursor to redraw text

            display.print("> ");

            display.print(menuItems[i]); // Redraw the text for the selected item

        }

    }


    display.display(); // Update the display with the drawn content

}


// Function to launch the selected application

void openApp(int appIndex) {

    inApp = true; // Set flag to indicate an app is running

    display.clearDisplay(); // Clear display

    display.setTextSize(1);

    display.setTextColor(SSD1306_WHITE);

    display.setCursor(0, 0);

    display.print("Opening: ");

    display.println(menuItems[appIndex]); // Display which app is opening

    display.display();

    delay(500); // Short delay


    // Use a switch statement to call the corresponding app function

    switch (appIndex) {

        case 0: runCalculator(); break;

        case 1: runStopwatch(); break;

        case 2: runAlarm(); break;

        case 3: runSnake(); break;

        case 4: runDistance(); break;

        case 5: runTemperature(); break;

        case 6: runSunlight(); break;

        case 7: runPong(); break;

        case 8: runWifiScanner(); break;

        case 9: runNotesApp(); break;

        case 10: runDice(); break;

        case 11: runPaint(); 

        break;

  case 12: runDistanceConverter();

        break;

  case 13: runBMI();

        break;

 case 14: runTimer();

        break;

        

        case 15: runSpaceShooter();

        break;
        
 case 16: runSciCalculator();
        break;
        
case 17: runElements();
        break;
case 18: runCommandPrompt();
        break;

        

        

      

    }

    inApp = false; // Reset flag when app exits

}


// ==================== PART 2: APP FUNCTIONS (HELPER FUNCTIONS) ====================

// Helper functions for reading button and joystick states


static inline bool backPressed() { return digitalRead(BACK_BTN) == LOW; } // True if back button is pressed

static inline bool joyPressed()  { return digitalRead(JOY_BTN)  == LOW; } // True if joystick button is pressed

static inline int joyX() { return analogRead(JOY_X); } // Read joystick X-axis analog value

static inline int joyY() { return analogRead(JOY_Y); } // Read joystick Y-axis analog value


// Check for joystick movement (debounced)

static bool joyMovedLeft(unsigned long &gateTs) {

    if (joyX() < JOY_CENTER - JOY_DEADZONE && millis() - gateTs > NAV_DELAY) { gateTs = millis(); return true; }

    return false;

}

static bool joyMovedRight(unsigned long &gateTs) {

    if (joyX() > JOY_CENTER + JOY_DEADZONE && millis() - gateTs > NAV_DELAY) { gateTs = millis(); return true; }

    return false;

}

static bool joyMovedUp(unsigned long &gateTs) {

    if (joyY() < JOY_CENTER - JOY_DEADZONE && millis() - gateTs > NAV_DELAY) { gateTs = millis(); return true; }

    return false;

}

static bool joyMovedDown(unsigned long &gateTs) {

    if (joyY() > JOY_CENTER + JOY_DEADZONE && millis() - gateTs > NAV_DELAY) { gateTs = millis(); return true; }

    return false;

}

// Wait for a button to be released

static void waitRelease(uint8_t pin) {

    while (digitalRead(pin) == LOW) delay(10); // Poll until button is released

}


// Helper function to draw multiline text with basic word wrapping

void drawMultiline(String text, int x, int y, int maxCharsPerLine) {

    String currentLine = "";

    String remainingText = text;

    int lastSpace = -1;


    display.setCursor(x, y);


    while (remainingText.length() > 0) {

        currentLine = "";

        int cutIndex = maxCharsPerLine;

        if (remainingText.length() <= maxCharsPerLine) {

            currentLine = remainingText;

            remainingText = "";

        } else {

            cutIndex = remainingText.lastIndexOf(' ', maxCharsPerLine);

            if (cutIndex == -1) { // No space found, hard wrap

                cutIndex = maxCharsPerLine;

            }

            currentLine = remainingText.substring(0, cutIndex);

            remainingText = remainingText.substring(cutIndex + (cutIndex != maxCharsPerLine ? 1 : 0));

        }

        display.println(currentLine);

    }

}



// ---------------------------------------------------------------------------------------------------------------------------------------


// Sunlight Alarm Application

void runSunlight() {

    const int SUNLIGHT_THRESHOLD = 3000; // Threshold for determining "bright"

    pinMode(BUZZER_PIN, OUTPUT); // Set buzzer pin as output

    analogReadResolution(12);    // Ensure ADC resolution is 12 bits


    while (!backPressed()) { // Loop until back button is pressed

        int ldrValue = analogRead(LDR_PIN); // Read LDR sensor value

        bool isBright = ldrValue > SUNLIGHT_THRESHOLD; // Check if it's bright


        digitalWrite(BUZZER_PIN, isBright ? HIGH : LOW); // Activate buzzer if bright


        display.clearDisplay();

        display.setTextSize(1);

        display.setTextColor(SSD1306_WHITE);

        display.setCursor(0, 0);

        display.print(F("Sunlight Alarm"));

        display.setCursor(0, 16);

        display.print(F("LDR Value: "));

        display.print(ldrValue);

        display.setTextSize(2); // Larger text for alarm status

        display.setCursor(10, 38);

        if (isBright) {

            display.print(F("ALARM!")); // Display alarm message

        } else {

            display.print(F("Dark...")); // Display dark message

        }

        display.display();

        delay(100); // Small delay for refresh

    }

    digitalWrite(BUZZER_PIN, LOW); // Turn off buzzer when exiting

    waitRelease(BACK_BTN);

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Calculator Application

void runCalculator() {

    // Keypad layout for the calculator

    const char keys[5][4] = {

        {'7','8','9','/'},

        {'4','5','6','*'},

        {'1','2','3','-'},

        {'0','.','=','+'},

        {'C','<','_',' '} // C=Clear, <=Backspace, _=Sign Change

    };


    int row = 0, col = 0;         // Cursor position on the virtual keypad

    unsigned long gateTs = 0;     // Timestamp for joystick navigation debouncing


    String current = "";          // Current number being entered

    double result = 0.0;          // Accumulated calculation result

    char op = 0;                  // Current operator (+, -, *, /)

    bool showedResult = false;    // Flag if the result is currently displayed


    // Lambda function to apply arithmetic operation

    auto applyOp = [&](double lhs, char oper, double rhs) -> double {

        if (oper == '+') return lhs + rhs;

        if (oper == '-') return lhs - rhs;

        if (oper == '*') return lhs * rhs;

        if (oper == '/') return (rhs != 0.0) ? (lhs / rhs) : 0.0; // Handle division by zero

        return rhs;

    };


    // Lambda function to process a number or operator input

    auto pushNumberThen = [&](char newOpOrEq){

        if (current.length() == 0) { // If no number entered, just set the operator

            if (newOpOrEq != '=') op = newOpOrEq;

            return;

        }

        double v = current.toDouble(); // Convert current input to a number

        if (op == 0) result = v;       // If no previous operator, set result to current number

        else result = applyOp(result, op, v); // Apply previous operation

        current = "";                  // Clear current input

        if (newOpOrEq == '=') { op = 0; showedResult = true; } // If '=', clear operator and show result

        else { op = newOpOrEq; showedResult = false; }         // Otherwise, set new operator

    };


    while (!backPressed()) { // Loop until back button is pressed

        // Handle joystick navigation for keypad cursor

        if (joyMovedLeft(gateTs))  col = (col + 3) % 4;

        if (joyMovedRight(gateTs)) col = (col + 1) % 4;

        if (joyMovedUp(gateTs))    row = (row + 4) % 5;

        if (joyMovedDown(gateTs))  row = (row + 1) % 5;


        if (joyPressed()) { // If joystick button is pressed

            waitRelease(JOY_BTN); // Wait for button release

            char key = keys[row][col]; // Get the selected key


            // Handle different key actions

            if (key == 'C') { // Clear

                current = ""; result = 0; op = 0; showedResult = false;

            }

            else if (key == '<') { // Backspace

                if (current.length()) current.remove(current.length()-1);

            }

            else if (key == '_') { // Change sign (+/-)

                if (current.length() == 0 && result != 0) { current = String(-result, 4); result = 0; } // Apply to result if no current input

                else if (current.startsWith("-")) current.remove(0,1); // Remove negative sign

                else current = "-" + current; // Add negative sign

            }

            else if (key == '=') { // Equals

                pushNumberThen('=');

            }

            else if (strchr("+-*/", key)) { // Operator keys

                pushNumberThen(key);

            }

            else if (key == '.') { // Decimal point

                if (showedResult) { current = "0"; showedResult = false; } // Start new number if result was showing

                if (current.indexOf('.') < 0) current += "."; // Add if not already present

            }

            else if (isdigit(key)) { // Digit keys

                if (showedResult) { current = ""; showedResult = false; } // Start new number if result was showing

                if (current == "0") current = key; else current += key; // Append digit

            }

        }


        display.clearDisplay(); // Clear display for redraw

        display.drawRect(0, 0, 128, 20, SSD1306_WHITE); // Draw display area border

        display.setTextSize(2); // Set text size for numbers

        display.setTextColor(SSD1306_WHITE);

        display.setCursor(4, 4); // Set cursor for display output


        String displayText = showedResult ? String(result, 4) : current; // Display result or current input

        if (displayText.length() == 0) {

            displayText = (op == 0) ? String(result, 4) : String(result, 2) + op; // Show current result or result with operator

        }

        if(displayText.length() > 10) displayText = displayText.substring(displayText.length() - 10); // Truncate if too long

        display.print(displayText);


        // Draw virtual keypad

        display.setTextSize(1);

        for (int r = 0; r < 5; r++) {

            for (int c = 0; c < 4; c++) {

                if (keys[r][c] == ' ') continue; // Skip empty key

                int x = c * 32; // X position for key

                int y = 22 + r * 9; // Y position for key

                bool sel = (r == row && c == col); // Check if current key is selected

                if (sel) { display.fillRect(x, y, 31, 9, SSD1306_WHITE); display.setTextColor(SSD1306_BLACK); } // Highlight selected

                else { display.setTextColor(SSD1306_WHITE); } // Normal color

                int tx = x + 12; // Text X position

                display.setCursor(tx, y + 1);

                display.print(keys[r][c] == '_' ? "+/-" : String(keys[r][c])); // Print key text

            }

        }

        display.display(); // Update display

        delay(10); // Small delay

    }

    waitRelease(BACK_BTN);

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Stopwatch Application

void runStopwatch() {

    unsigned long startMs = 0;  // Timestamp when stopwatch started/resumed

    unsigned long pausedMs = 0; // Total time elapsed when paused

    bool running = false;       // Flag to indicate if stopwatch is running


    // Lambda function to calculate elapsed time

    auto elapsedMs = [&]() -> unsigned long {

        if (running) return millis() - startMs; // If running, current time - start time

        return pausedMs; // If paused, return stored paused time

    };


    unsigned long pressTs = 0; // Timestamp of joystick button press

    bool pressed = false;      // Flag to track joystick button press state


    while (!backPressed()) { // Loop until back button is pressed

        // Detect joystick button press and release for start/stop/reset

        if (!pressed && joyPressed()) { pressed = true; pressTs = millis(); }

        if (pressed && !joyPressed()) {

            unsigned long dur = millis() - pressTs; // Duration of button press

            if (dur > 800) { // Long press to reset

                running = false; startMs = 0; pausedMs = 0;

            } else { // Short press to start/stop

                if (!running) {

                    running = true;

                    startMs = millis() - pausedMs; // Adjust start time for resuming

                } else {

                    running = false;

                    pausedMs = millis() - startMs; // Store elapsed time when stopping

                }

            }

            pressed = false; // Reset pressed flag

        }


        unsigned long ms = elapsedMs();       // Get total elapsed milliseconds

        unsigned long totalSec = ms / 1000UL; // Convert to total seconds

        uint16_t mins = totalSec / 60;        // Calculate minutes

        uint8_t secs  = totalSec % 60;        // Calculate seconds

        uint16_t centisecs = (ms % 1000) / 10; // Calculate centiseconds


        display.clearDisplay(); // Clear display

        display.setTextSize(1); display.setTextColor(SSD1306_WHITE);

        display.setCursor(0,0); display.print(F("Press=Start/Stop, Hold=Reset")); // Instructions

        display.setTextSize(3); // Larger text for time display

        display.setCursor(10, 24);


        // Format and display minutes:seconds.centiseconds

        if (mins < 10) display.print("0");

        display.print(mins);

        display.print(":");

        if (secs < 10) display.print("0");

        display.print(secs);

        display.setTextSize(2); // Smaller text for centiseconds

        display.setCursor(95, 30);

        if (centisecs < 10) display.print("0");

        display.print(centisecs);


        display.display(); // Update display

        delay(50); // Small delay for refresh rate

    }

    waitRelease(BACK_BTN); // Wait for back button release

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Alarm Application (Simple Buzzer)

void runAlarm() {

    display.clearDisplay();

    display.setTextSize(2); display.setTextColor(SSD1306_WHITE);

    display.setCursor(18, 8);  display.print(F("ALARM")); // Display "ALARM"

    display.setTextSize(1);

    display.setCursor(12, 32); display.print(F("Buzzer is ON")); // Indicate buzzer status

    display.setCursor(8, 46);  display.print(F("Press BACK to stop")); // Instructions

    display.display();


    pinMode(BUZZER_PIN, OUTPUT); // Set buzzer pin as output

    unsigned long toneStart = millis(); // Timestamp for buzzer toggling


    while (!backPressed()) { // Loop until back button is pressed

        if(millis() - toneStart > 200){ // Toggle buzzer every 200ms

            digitalWrite(BUZZER_PIN, !digitalRead(BUZZER_PIN)); // Invert buzzer state

            toneStart = millis(); // Update timestamp

        }

        delay(10); // Small delay

    }

    digitalWrite(BUZZER_PIN, LOW); // Turn off buzzer when exiting

    waitRelease(BACK_BTN);

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Snake Game Application

#define CELL 4      // Size of each snake/fruit cell in pixels

#define GRID_W (128 / CELL) // Grid width in cells

#define GRID_H (64 / CELL)  // Grid height in cells

#define MAX_LEN 80  // Maximum length of the snake


void runSnake() {

    uint8_t sx[MAX_LEN], sy[MAX_LEN]; // Arrays to store snake segment coordinates

    int length = 4;                 // Initial snake length

    int headX = GRID_W/2, headY = GRID_H/2; // Initial head position

    int vx = 1, vy = 0;             // Initial velocity (moving right)


    // Initialize snake body segments

    for (int i=0;i<length;i++){ sx[i]=headX-i; sy[i]=headY; }


    // Lambda function to place fruit at a random, unoccupied location

    auto placeFruit = [&]() -> uint16_t {

        int fx, fy;

        bool onSnake;

        do {

            onSnake = false;

            fx = random(0, GRID_W); // Random X coordinate

            fy = random(0, GRID_H); // Random Y coordinate

            // Check if proposed fruit location is on the snake

            for(int i = 0; i < length; i++){

                if(sx[i] == fx && sy[i] == fy){ onSnake = true; break; }

            }

        } while(onSnake); // Keep trying until not on snake

        return (uint16_t)fx << 8 | (uint16_t)fy; // Pack x, y into a single uint16_t

    };


    randomSeed(analogRead(0)); // Seed random number generator (using unconnected analog pin for noise)

    uint16_t fruit = placeFruit(); // Place initial fruit

    int fx = fruit >> 8, fy = fruit & 0xFF; // Unpack fruit coordinates

    unsigned long stepTs = 0;       // Timestamp of last snake movement

    const unsigned long stepEvery = 160; // Milliseconds per snake step (controls speed)


    while (!backPressed()) { // Loop until back button is pressed

        // Change snake direction based on joystick input

        if (joyX() < JOY_CENTER - JOY_DEADZONE && vx != 1)  { vx=-1; vy=0; } // Left

        if (joyX() > JOY_CENTER + JOY_DEADZONE && vx != -1) { vx=1;  vy=0; } // Right

        if (joyY() < JOY_CENTER - JOY_DEADZONE && vy != 1)  { vx=0;  vy=-1; } // Up

        if (joyY() > JOY_CENTER + JOY_DEADZONE && vy != -1) { vx=0;  vy=1; } // Down


        if (millis() - stepTs >= stepEvery) { // Time for next snake step

            stepTs = millis();

            // Move snake segments (shift all segments to the position of the one in front)

            for (int i=length-1; i>0; --i) { sx[i]=sx[i-1]; sy[i]=sy[i-1]; }

            // Move snake head based on current velocity, wrap around edges

            sx[0] = (sx[0] + vx + GRID_W) % GRID_W;

            sy[0] = (sy[0] + vy + GRID_H) % GRID_H;


            // Check for collision with self

            for (int i=1;i<length;i++){ if (sx[0]==sx[i] && sy[0]==sy[i]) { goto game_over; } }


            // Check for fruit collision

            if (sx[0]==fx && sy[0]==fy) {

                if (length < MAX_LEN) { length++; } // Increase length if not at max

                fruit = placeFruit(); // Place new fruit

                fx = fruit >> 8;

                fy = fruit & 0xFF;

            }

        }


        display.clearDisplay(); // Clear display

        display.fillRect(fx*CELL, fy*CELL, CELL, CELL, SSD1306_WHITE); // Draw fruit

        // Draw snake segments

        for (int i=0;i<length;i++) display.fillRect(sx[i]*CELL, sy[i]*CELL, CELL, CELL, SSD1306_WHITE);

        display.display(); // Update display

        delay(10); // Small delay for rendering

    }


    waitRelease(BACK_BTN); // Wait for back button release

    return;


    // Game Over label (goto target)

    game_over:

    display.clearDisplay();

    display.setTextSize(2); display.setTextColor(SSD1306_WHITE);

    display.setCursor(16, 14); display.print(F("GAME OVER")); // Display "GAME OVER"

    display.setTextSize(1);

    display.setCursor(22, 38); display.print(F("Score: ")); display.print(length - 4); // Display score

    display.setCursor(10, 50); display.print(F("Press BACK to exit")); // Instructions

    display.display();

    while (!backPressed()) delay(10); // Wait for back button press

    waitRelease(BACK_BTN); // Wait for back button release

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Distance Sensor Application (Ultrasonic)

void runDistance() {

    pinMode(TRIG_PIN, OUTPUT); // Trigger pin as output

    pinMode(ECHO_PIN, INPUT);  // Echo pin as input


    while (!backPressed()) { // Loop until back button is pressed

        // Send a 10us pulse on the trigger pin

        digitalWrite(TRIG_PIN, LOW);  delayMicroseconds(2);

        digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);

        digitalWrite(TRIG_PIN, LOW);


        // Measure the duration of the pulse on the echo pin

        // Timeout 38000us (approx. 6.5m distance)

        long duration = pulseIn(ECHO_PIN, HIGH, 38000);

        // Calculate distance in cm (speed of sound 0.0343 cm/us, divided by 2 for round trip)

        float cm = (duration > 0) ? (duration * 0.0343f / 2.0f) : -1.0f;


        display.clearDisplay();

        display.setTextSize(1); display.setTextColor(SSD1306_WHITE);

        display.setCursor(0,0); display.print(F("Distance Sensor")); // Title

        display.setTextSize(3); display.setCursor(0,24);

        if (cm > 0 && cm < 900) { // If within valid range

            display.print(cm, 1); // Display distance with 1 decimal place

            display.setTextSize(2);

            display.print(F(" cm"));

        } else { // Out of range or no measurement

            display.setTextSize(1);

            display.setCursor(0,32);

            display.print(F("Out of Range"));

        }

        display.display(); // Update display

        delay(120); // Small delay

    }

    waitRelease(BACK_BTN); // Wait for back button release

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Temperature Sensor Application (Thermistor)

void runTemperature() {

    const float BETA = 3435.0f;    // Beta coefficient of the thermistor

    const float R_FIXED = 10000.0f; // Value of the fixed resistor in the voltage divider (10k Ohm)

    analogReadResolution(12);       // Ensure ADC resolution is 12 bits


    while (!backPressed()) { // Loop until back button is pressed

        int adc = 0;

        // Take multiple readings and average them for stability

        for(int i=0; i<5; i++){ adc += analogRead(THERM_PIN); delay(5); }

        adc /= 5;


        if (adc < 1) adc = 1; // Prevent division by zero or log of zero

        // Calculate thermistor resistance using voltage divider formula

        float rTherm = R_FIXED * (4095.0f / (float)adc - 1.0f);

        // Steinhart-Hart equation (simplified) to convert resistance to temperature

        float lnR = log(rTherm / 10000.0f); // Natural log of R/R0 (R0 is resistance at 25C, assumed 10k)

        float invT = (1.0f / 298.15f) + (lnR / BETA); // Inverse of temperature in Kelvin

        float tempK = 1.0f / invT; // Temperature in Kelvin

        float tempC = tempK - 273.15f; // Convert to Celsius

        float tempF = tempC * 9.0 / 5.0 + 32.0; // Convert to Fahrenheit


        display.clearDisplay();

        display.setTextSize(1); display.setTextColor(SSD1306_WHITE);

        display.setCursor(0,0); display.print(F("Temperature")); // Title

        display.setTextSize(2); // Larger text for temperature values

        display.setCursor(0,20);

        display.print(tempC, 1); display.print(F(" C")); // Display Celsius

        display.setCursor(0,44);

        display.print(tempF, 1); display.print(F(" F")); // Display Fahrenheit

        display.display(); // Update display

        delay(500); // Refresh every 500ms

    }

    waitRelease(BACK_BTN); // Wait for back button release

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Pong Game Application

#define PADDLE_WIDTH 2   // Width of the paddles

#define PADDLE_HEIGHT 12 // Height of the paddles

#define BALL_SIZE 2      // Size of the ball (square)


void runPong() {

    int scorePlayer = 0; // Player's score

    int scoreCPU = 0;    // CPU's score

    int playerY = (SCREEN_HEIGHT - PADDLE_HEIGHT) / 2; // Initial player paddle Y position

    int cpuY = (SCREEN_HEIGHT - PADDLE_HEIGHT) / 2;    // Initial CPU paddle Y position

    float ballX = SCREEN_WIDTH / 2;  // Initial ball X position

    float ballY = SCREEN_HEIGHT / 2; // Initial ball Y position

    float ballVX = 1.5;              // Ball velocity in X direction

    float ballVY = 1.0;              // Ball velocity in Y direction

    unsigned long lastMoveTime = 0;  // Timestamp for player paddle movement

    unsigned long cpuLastMoveTime = 0; // Timestamp for CPU paddle movement


    // Lambda function to reset ball position and direction after a score

    auto resetBall = [&]() {

        ballX = SCREEN_WIDTH / 2;

        ballY = SCREEN_HEIGHT / 2;

        ballVX *= -1.0; // Reverse X direction for next serve

        ballVY = random(10, 20) / 10.0; // Randomize Y velocity slightly

    };


    // Game loop continues until back button is pressed or score limit reached

    while (!backPressed() && scorePlayer < 5 && scoreCPU < 5) {

        int yValue = joyY(); // Read joystick Y for player paddle control

        if (millis() - lastMoveTime > 10) { // Player paddle movement debouncing

            if (yValue < (JOY_CENTER - JOY_DEADZONE)) {

                playerY = max(0, playerY - 2); // Move player paddle up

                lastMoveTime = millis();

            } else if (yValue > (JOY_CENTER + JOY_DEADZONE)) {

                playerY = min(SCREEN_HEIGHT - PADDLE_HEIGHT, playerY + 2); // Move player paddle down

                lastMoveTime = millis();

            }

        }


        // CPU paddle AI (simple tracking)

        int cpuDelay = map(scorePlayer, 0, 4, 10, 5); // CPU speed increases with player score

        if (millis() - cpuLastMoveTime > cpuDelay) {

            if (ballY < cpuY + PADDLE_HEIGHT / 2) {

                cpuY = max(0, cpuY - 1); // Move CPU paddle up

            } else if (ballY > cpuY + PADDLE_HEIGHT / 2) {

                cpuY = min(SCREEN_HEIGHT - PADDLE_HEIGHT, cpuY + 1); // Move CPU paddle down

            }

            cpuLastMoveTime = millis();

        }


        // Update ball position

        ballX += ballVX;

        ballY += ballVY;


        // Ball collision with top/bottom walls

        if (ballY <= 0 || ballY >= SCREEN_HEIGHT - BALL_SIZE) {

            ballVY *= -1; // Reverse Y velocity

        }


        // Ball collision with player paddle

        if (ballX >= SCREEN_WIDTH - PADDLE_WIDTH - BALL_SIZE && ballY + BALL_SIZE >= playerY && ballY <= playerY + PADDLE_HEIGHT) {

            ballVX = -1 * min(abs(ballVX * 1.1), 3.0); // Reverse X velocity, increase speed slightly, cap at 3.0

            ballVY = min(abs(ballVY * 1.1), 3.0);      // Increase Y velocity, cap at 3.0

            ballX = SCREEN_WIDTH - PADDLE_WIDTH - BALL_SIZE - 1; // Prevent ball from getting stuck

        }


        // Ball collision with CPU paddle

        if (ballX <= PADDLE_WIDTH && ballY + BALL_SIZE >= cpuY && ballY <= cpuY + PADDLE_HEIGHT) {

            ballVX = 1 * min(abs(ballVX * 1.1), 3.0); // Reverse X velocity, increase speed slightly, cap at 3.0

            ballVY = min(abs(ballVY * 1.1), 3.0);     // Increase Y velocity, cap at 3.0

            ballX = PADDLE_WIDTH + 1; // Prevent ball from getting stuck

        }


        // Check for scoring (ball goes off screen)

        if (ballX < 0) {

            scorePlayer++; // Player scores

            resetBall();   // Reset ball for next round

        }

        if (ballX > SCREEN_WIDTH) {

            scoreCPU++; // CPU scores

            resetBall(); // Reset ball for next round

        }


        display.clearDisplay(); // Clear display for redraw

        display.setTextSize(1);

        display.setTextColor(SSD1306_WHITE);


        // Display scores

        display.setCursor(SCREEN_WIDTH / 2 - 20, 0);

        display.print(scoreCPU);

        display.setCursor(SCREEN_WIDTH / 2 + 10, 0);

        display.print(scorePlayer);


        // Draw middle dashed line

        for (int i = 0; i < SCREEN_HEIGHT; i += 4) {

            display.drawPixel(SCREEN_WIDTH / 2, i, SSD1306_WHITE);

        }


        // Draw paddles and ball

        display.fillRect(0, cpuY, PADDLE_WIDTH, PADDLE_HEIGHT, SSD1306_WHITE); // CPU paddle

        display.fillRect(SCREEN_WIDTH - PADDLE_WIDTH, playerY, PADDLE_WIDTH, PADDLE_HEIGHT, SSD1306_WHITE); // Player paddle

        display.fillRect(ballX, ballY, BALL_SIZE, BALL_SIZE, SSD1306_WHITE); // Ball


        display.display(); // Update display

        delay(10); // Small delay for animation

    }


    // Game Over screen

    display.clearDisplay();

    display.setTextSize(2);

    display.setCursor(16, 14);

    display.print(F("GAME OVER"));

    display.setTextSize(1);

    display.setCursor(20, 38);

    if (scorePlayer > scoreCPU) {

        display.print(F("YOU WIN!"));

    } else {

        display.print(F("YOU LOSE!"));

    }

    display.setCursor(10, 50);

    display.print(F("Press BACK to exit"));

    display.display();

    while (!backPressed()) delay(10); // Wait for back button press

    waitRelease(BACK_BTN); // Wait for back button release

}


// ---------------------------------------------------------------------------------------------------------------------------------------


// Wifi Scanner Application

String getSignalStrengthStatus(long rssi) {

    if (rssi >= -40) {

        return "Excellent";

    } else if (rssi >= -60) {

        return "Good";

    } else if (rssi >= -70) {

        return "Fair";

    } else {

        return "Poor";

    }

}


void runWifiScanner() {

    display.clearDisplay();

    display.setTextSize(1);

    display.setTextColor(SSD1306_WHITE);

    display.setCursor(0, 0);

    display.println("Scanning for WiFi...");

    display.display();

    

    // Set ESP32 to Wi-Fi station mode to scan networks.

    WiFi.mode(WIFI_STA);

    WiFi.disconnect(); // Disconnect from any previous networks

    int n = WiFi.scanNetworks(); // Perform Wi-Fi scan, returns number of networks found


    if (n == 0) { // If no networks found

        display.clearDisplay();

        display.println("No networks found.");

        display.display();

        delay(2000);

        WiFi.scanDelete(); // Delete scan results to free memory

        WiFi.mode(WIFI_OFF); // Turn off Wi-Fi to save power

        return; // Exit the app

    }


    int currentWifiSelection = 0;       // Index of the currently selected Wi-Fi network

    unsigned long lastNavTime = 0;    // Timestamp for menu navigation debouncing

    int firstVisibleItem = 0;          // Index of the first item shown on the screen

    const int MAX_WIFI_ITEMS = 5;      // Maximum Wi-Fi networks to display at once


    // Phase 1: Display the list of Wi-Fi networks and allow selection

    while(!backPressed()) {

        if (joyPressed()){

          waitRelease(JOY_BTN);

          break; // Exit loop to go to phase 2

        }


        // Handle vertical navigation with joystick

        if (joyMovedUp(lastNavTime)) {

            currentWifiSelection--;

            if (currentWifiSelection < 0) currentWifiSelection = n - 1; // Wrap around

        }

        if (joyMovedDown(lastNavTime)) {

            currentWifiSelection++;

            if (currentWifiSelection >= n) currentWifiSelection = 0; // Wrap around

        }


        // Adjust visible window of networks if selection goes off screen

        if (currentWifiSelection < firstVisibleItem) {

            firstVisibleItem = currentWifiSelection;

        }

        if (currentWifiSelection >= firstVisibleItem + MAX_WIFI_ITEMS) {

            firstVisibleItem = currentWifiSelection - (MAX_WIFI_ITEMS - 1);

        }


        display.clearDisplay();

        display.setCursor(0, 0);

        display.setTextSize(1);

        display.println("Select a Network:");

        display.drawFastHLine(0, 10, 127, SSD1306_WHITE); // Separator line


        // Draw visible network items

        for (int i = 0; i < MAX_WIFI_ITEMS && (firstVisibleItem + i) < n; i++) {

            int itemIndex = firstVisibleItem + i;

            String ssid = WiFi.SSID(itemIndex); // Get SSID

            long rssi = WiFi.RSSI(itemIndex);   // Get RSSI


            display.setCursor(0, 16 + i * 9); // Position for current item

            // Highlight selected item

            if (itemIndex == currentWifiSelection) {

                display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // Black text on white background

            } else {

                display.setTextColor(SSD1306_WHITE); // White text on black background

            }


            // Truncate long SSIDs

            if (ssid.length() > 15) {

                ssid = ssid.substring(0, 12) + "...";

            }

            display.print(ssid);

            display.print(" (");

            display.print(rssi);

            display.print(")");

        }

        display.display(); // Update display

        delay(10);

    }

    

    // If the user pressed the back button, exit the app now

    if (backPressed()) {

        WiFi.scanDelete();

        WiFi.mode(WIFI_OFF);

        waitRelease(BACK_BTN);

        return;

    }


    String selectedSSID = WiFi.SSID(currentWifiSelection); // Store selected SSID

    

    // Delete scan results to free up memory

    WiFi.scanDelete();


    // Phase 2: Display the real-time RSSI graph for the selected network

    const int HISTORY_SIZE = 64; // Number of historical RSSI points to store

    int history[HISTORY_SIZE] = {0}; // Array to store historical RSSI values

    int historyIndex = 0;             // Current index in the circular history buffer

    unsigned long lastReadTime = 0; // Timestamp of last RSSI reading

    const unsigned long READ_INTERVAL = 250; // Interval for reading RSSI


    while (!backPressed()) { // Loop until back button is pressed

        if (millis() - lastReadTime >= READ_INTERVAL) { // Time to take a new reading

            lastReadTime = millis();

            

            // Perform a quick scan to get the latest RSSI for the selected network

            int newScanCount = WiFi.scanNetworks(false, true); // non-blocking, hidden networks allowed

            long currentRssi = -100; // Default to a low value if network is not found

            for (int i = 0; i < newScanCount; i++) {

                if (WiFi.SSID(i) == selectedSSID) {

                    currentRssi = WiFi.RSSI(i);

                    break;

                }

            }

            

            history[historyIndex] = currentRssi; // Store in history

            historyIndex = (historyIndex + 1) % HISTORY_SIZE; // Advance index (circular)

            WiFi.scanDelete(); // Delete scan results to free memory

        }


        // Calculate min, max, and average RSSI for dynamic graph scaling and display

        int minRssi = -100; // Default min for mapping

        int maxRssi = -30;  // Default max for mapping

        long totalRssi = 0;

        int validCount = 0;

        for (int i = 0; i < HISTORY_SIZE; i++) {

            if (history[i] != 0) { // Only consider valid readings

                if (history[i] < minRssi) minRssi = history[i];

                if (history[i] > maxRssi) maxRssi = history[i];

                totalRssi += history[i];

                validCount++;

            }

        }

        long averageRssi = validCount > 0 ? totalRssi / validCount : 0;

        // Ensure min and max are not identical to prevent map() issues

        if (minRssi == maxRssi) {

            minRssi -= 5;

            maxRssi += 5;

        }


        display.clearDisplay();

        display.setTextSize(1);

        display.setTextColor(SSD1306_WHITE);

        display.setCursor(0, 0);

        display.print("Tracking: ");

        // Display selected SSID (truncated if too long)

        display.println(selectedSSID.substring(0, min(14, (int)selectedSSID.length())));


        display.setCursor(0, 8);

        display.print("Avg: ");

        display.print(averageRssi);

        display.println(" dBm"); // Display average RSSI


        display.setCursor(0, 16);

        // Get and display signal quality status

        String signalStatus = getSignalStrengthStatus(history[(historyIndex + HISTORY_SIZE - 1) % HISTORY_SIZE]);

        display.print("Status: ");

        display.println(signalStatus);


        // Draw the graph area border

        display.drawRect(0, 30, 128, 34, SSD1306_WHITE);

        // Display min/max RSSI labels on the Y-axis

        display.setCursor(1, 32); display.print(maxRssi);

        display.setCursor(1, 56); display.print(minRssi);


        // Draw the filled area graph for RSSI history

        // Iterates through history, mapping RSSI to Y position and drawing vertical lines

        for (int i = 0; i < HISTORY_SIZE; i++) {

          // Map RSSI value to screen Y coordinate (inverted for graph display)

          // `63` is the bottom of the graph area, `31` is the top

          int y1 = map(history[(historyIndex + i) % HISTORY_SIZE], minRssi, maxRssi, 63, 31);

          if (history[(historyIndex + i) % HISTORY_SIZE] != 0) { // Only draw valid points

            // Draw a vertical line from the bottom of the graph to the data point

            display.drawLine(1 + i*2, 63, 1 + i*2, y1, SSD1306_WHITE);

          }

        }

        

        display.display(); // Update the display

        delay(10); // Small delay for smooth updates

    }

    

    WiFi.mode(WIFI_OFF); // Turn off Wi-Fi

    waitRelease(BACK_BTN); // Wait for back button release

}


// =======================================================================================

// ==================== NEWLY ADDED APPLICATIONS =========================================

// =======================================================================================


// ---------------------------------------------------------------------------------------------------------------------------------------


// Notes Application

void runNotesApp() {

  const char chars[] = "abcdefghijklmnopqrstuvwxyz _<"; 

  String note = "";

  int charIndex = 0;

  bool onDelete = false; // true = delete button selected

  unsigned long gateTs = 0;


  while (!backPressed()) {


    // --- Move Left/Right when not on delete button ---

    if (!onDelete) {

      if (joyMovedLeft(gateTs)) { 

        charIndex--;

        if (charIndex < 0) charIndex = strlen(chars) - 1;

      } else if (joyMovedRight(gateTs)) { 

        charIndex++;

        if (charIndex >= strlen(chars)) charIndex = 0;

      }

    }


    // --- Move Down to Delete button ---

    if (joyMovedDown(gateTs)) {  

      onDelete = true;

    }

    // --- Move Up back to typing mode ---

    else if (joyMovedUp(gateTs)) {

      onDelete = false;

    }


    // --- Joystick Button Press ---

    if (joyPressed()) {

      waitRelease(JOY_BTN);

      if (onDelete) {

        note = "";  // clear whole note

      } else {

        char c = chars[charIndex];

        if (c == '_') {

          note += ' ';

        } else if (c == '<') {

          if (note.length() > 0) note.remove(note.length() - 1);

        } else {

          note += c;

        }

      }

    }


    // --- Draw Screen ---

    display.clearDisplay();

    display.setTextSize(1);

    display.setTextColor(SSD1306_WHITE);

    display.setCursor(0, 0);

    display.println("Notes App");

    display.drawFastHLine(0, 8, 128, SSD1306_WHITE);


    // Show typed note

    display.setCursor(0, 12);

    display.println("Note:");

    drawMultiline(note, 0, 22, 21); // Use the helper to draw the note


    // Show delete button or current character selection

    if (onDelete) {

      display.setCursor(0, 54);

      display.setTextColor(SSD1306_BLACK, SSD1306_WHITE); // inverted highlight

      display.print("[DELETE NOTE]");

      display.setTextColor(SSD1306_WHITE); 

    } else {

      display.setCursor(0, 54);

      display.print("Char: '");

      if (chars[charIndex] == '_') display.print(" ");

      else if (chars[charIndex] == '<') display.print("Del");

      else display.print(chars[charIndex]);

      display.print("'");

    }


    display.display();

    delay(10);

  }

  waitRelease(BACK_BTN);

}



// ---------------------------------------------------------------------------------------------------------------------------------------


// Dice Roller Application

void runDice() {

    int count = 2; // number of dice (1..6)

    const int sidesOptions[] = {4, 6, 8, 10, 12, 20};

    int sidesIdx = 1; // start at d6

    int results[6] = {0,0,0,0,0,0};

    int sum = 0;


    unsigned long gateTs = 0;

    randomSeed(esp_random()); // good entropy on ESP32


    auto doRoll = [&](){

        // quick animation

        for (int frame=0; frame<10; ++frame) {

            for (int i=0;i<count;i++) results[i] = random(1, sidesOptions[sidesIdx] + 1);

            sum = 0; for (int i=0;i<count;i++) sum += results[i];


            display.clearDisplay();

            display.setTextSize(1); display.setTextColor(SSD1306_WHITE);

            display.setCursor(0,0); display.print(F("Dice Roller  "));

            display.print(count); display.print("x d"); display.print(sidesOptions[sidesIdx]);


            // draw results grid

            int x = 0, y = 14;

            for (int i=0;i<count;i++) {

                display.drawRect(x, y, 40, 16, SSD1306_WHITE);

                display.setCursor(x+12, y+3);

                display.setTextSize(2);

                display.print(results[i]);

                display.setTextSize(1);

                x += 42;

                if (x + 40 > 128) { x = 0; y += 18; }

            }

            // sum

            display.setCursor(0, 52);

            display.print(F("Sum: "));

            display.setTextSize(2); display.setCursor(42, 48); display.print(sum);

            display.setTextSize(1);


            display.display();

            delay(40 + frame*6); // easing

        }

    };


    // initial preview

    doRoll();


    while (!backPressed()) {

        // controls

        if (joyMovedUp(gateTs))    { count = min(6, count + 1); doRoll(); }

        if (joyMovedDown(gateTs))  { count = max(1, count - 1); doRoll(); }

        if (joyMovedLeft(gateTs))  { sidesIdx = (sidesIdx + 5) % 6; doRoll(); }

        if (joyMovedRight(gateTs)) { sidesIdx = (sidesIdx + 1) % 6; doRoll(); }


        if (joyPressed()) {

            waitRelease(JOY_BTN);

            doRoll();

        }


        // passive UI refresh (no animation) to show current settings

        display.clearDisplay();

        display.setTextSize(1); display.setTextColor(SSD1306_WHITE);

        display.setCursor(0,0); display.print(count); display.print("x d"); display.print(sidesOptions[sidesIdx]);


        int x = 0, y = 14;

        sum = 0; for (int i=0;i<count;i++) sum += results[i];

        for (int i=0;i<count;i++) {

            display.drawRect(x, y, 40, 16, SSD1306_WHITE);

            display.setCursor(x+12, y+3);

            display.setTextSize(2);

            if (results[i] == 0) display.print("-");

            else display.print(results[i]);

            display.setTextSize(1);

            x += 42;9;

            

            if (x + 40 > 128) { x = 0; y += 18; }

        }


        display.setCursor(0, 52);

        display.print(F("Sum: "));

        display.setTextSize(2); display.setCursor(42, 48); display.print(sum);

        display.setTextSize(1);

        display.setCursor(68, 0); display.print(F("Press=Roll"));


        display.display();

        delay(10);

    }

    waitRelease(BACK_BTN);

}


// ==================== PAINT APP ====================

// ==================== PAINT APP ====================

// ==================== PAINT APP ====================

// ==================== PAINT APP ====================

void runPaint() {

  int cursorX = SCREEN_WIDTH / 2;

  int cursorY = SCREEN_HEIGHT / 2;

  bool penDown = false;      // true = drawing mode

  unsigned long pressStart = 0;


  display.clearDisplay();

  display.setTextSize(1);

  display.setCursor(0, 0);

  display.print("Paint");

  display.display();

  delay(800);


  display.clearDisplay();

  display.display();


  while (true) {

    int xVal = analogRead(JOY_X);

    int yVal = analogRead(JOY_Y);

    bool btn = digitalRead(JOY_BTN) == LOW;

    bool back = digitalRead(BACK_BTN) == LOW;


    // Exit app with BACK button

    if (back) {

      delay(200);

      return;

    }


    // Move cursor - adjust movement for 2x2 "pixel"

    if (xVal < 1000 && cursorX > 0) cursorX -= 2; // Move by 2 pixels

    if (xVal > 3000 && cursorX < SCREEN_WIDTH - 2) cursorX += 2; // Move by 2 pixels

    if (yVal < 1000 && cursorY > 0) cursorY -= 2; // Move by 2 pixels

    if (yVal > 3000 && cursorY < SCREEN_HEIGHT - 2) cursorY += 2; // Move by 2 pixels


    // Ensure cursor stays within bounds after movement

    cursorX = max(0, min(cursorX, SCREEN_WIDTH - 2));

    cursorY = max(0, min(cursorY, SCREEN_HEIGHT - 2));


    // --- Joystick button logic ---

    if (btn) {

      if (pressStart == 0) pressStart = millis();


      // If holding > 800ms → erase 2x2 pixel block under cursor

      if (millis() - pressStart > 800) {

        display.fillRect(cursorX, cursorY, 2, 2, SSD1306_BLACK); // Erase 2x2 block

        display.display();

      }

    } else {

      if (pressStart != 0) {

        // Short press toggles draw mode

        if (millis() - pressStart < 800) {

          penDown = !penDown;    // toggle pen

        }

        pressStart = 0;

      }

    }


    // If pen is down → draw while moving (2x2 pixel block)

    if (penDown) {

      display.fillRect(cursorX, cursorY, 2, 2, SSD1306_WHITE); // Draw 2x2 block

    }


    // Draw blinking cursor without erasing pixels (adjust for 2x2 "pixel")

    // This will draw a 4x4 inverse rectangle around the 2x2 drawing area

    display.drawRect(cursorX - 1, cursorY - 1, 4, 4, SSD1306_INVERSE);

    display.display();

    delay(100);

    display.drawRect(cursorX - 1, cursorY - 1, 4, 4, SSD1306_INVERSE);

    display.display();


    delay(30);

  }

}

// UNIT CONVETOR


// =============== SMARTPHONE STYLE DISTANCE CONVERTER ===============

void runDistanceConverter() {

  const char* units[] = {"Meter", "Km", "Cm", "Inch", "Foot"};

  int totalUnits = 5;


  int fromIndex = 0;   // default: Meter

  int toIndex = 4;     // default: Foot

  String input = "0";

  unsigned long gateTs = 0;


  int cursorPos = 0; // 0=From, 1=To, 2=Value


  while (!backPressed()) {

    // Navigation

    if (joyMovedUp(gateTs))    cursorPos = (cursorPos + 2) % 3;

    if (joyMovedDown(gateTs))  cursorPos = (cursorPos + 1) % 3;


    if (joyMovedLeft(gateTs)) {

      if (cursorPos == 0) fromIndex = (fromIndex - 1 + totalUnits) % totalUnits;

      if (cursorPos == 1) toIndex   = (toIndex - 1 + totalUnits) % totalUnits;

    }

    if (joyMovedRight(gateTs)) {

      if (cursorPos == 0) fromIndex = (fromIndex + 1) % totalUnits;

      if (cursorPos == 1) toIndex   = (toIndex + 1) % totalUnits;

    }


    // Enter number (open keypad)

    if (joyPressed() && cursorPos == 2) {

      waitRelease(JOY_BTN);

      input = openKeypad(input);  // open keypad to edit number

    }


    // Convert value

    float value = input.toFloat();

    float meters = convertToMeters(value, fromIndex);

    float result = convertFromMeters(meters, toIndex);


    // Draw UI

    display.clearDisplay();

    display.setTextSize(1);

    display.setCursor(0,0); display.println("Distance Conv");


    // From unit

    display.setCursor(0, 14);

    if (cursorPos == 0) display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

    else display.setTextColor(SSD1306_WHITE);

    display.print("From: "); display.println(units[fromIndex]);


    // To unit

    display.setCursor(0, 28);

    if (cursorPos == 1) display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

    else display.setTextColor(SSD1306_WHITE);

    display.print("To:   "); display.println(units[toIndex]);


    // Value

    display.setCursor(0, 42);

    if (cursorPos == 2) display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

    else display.setTextColor(SSD1306_WHITE);

    display.print("Value: "); display.println(input);


    // Result

    display.setTextColor(SSD1306_WHITE);

    display.setCursor(0, 56);

    display.print("= "); display.print(result, 3); 

    display.print(" "); display.println(units[toIndex]);


    display.display();

    delay(50);

  }

  waitRelease(BACK_BTN);

}


// --- Helper functions ---

float convertToMeters(float val, int unit) {

  if (unit==0) return val;            // Meter

  if (unit==1) return val*1000.0;     // Km

  if (unit==2) return val/100.0;      // Cm

  if (unit==3) return val*0.0254;     // Inch

  if (unit==4) return val*0.3048;     // Foot

  return val;

}

float convertFromMeters(float val, int unit) {

  if (unit==0) return val;

  if (unit==1) return val/1000.0;

  if (unit==2) return val*100.0;

  if (unit==3) return val/0.0254;

  if (unit==4) return val/0.3048;

  return val;

}


// --- Virtual keypad function (reuse from calculator) ---

String openKeypad(String current) {

  const char keys[4][4] = {

    {'7','8','9',' '},

    {'4','5','6',' '},

    {'1','2','3',' '},

    {'0','.','C','<'}

  };

  int row=0, col=0;

  unsigned long ts=0;

  String input=current;


  while (!backPressed()) {

    if (joyMovedLeft(ts))  col = (col + 3) % 4;

    if (joyMovedRight(ts)) col = (col + 1) % 4;

    if (joyMovedUp(ts))    row = (row + 3) % 4;

    if (joyMovedDown(ts))  row = (row + 1) % 4;


    if (joyPressed()) {

      waitRelease(JOY_BTN);

      char key = keys[row][col];

      if (key >= '0' && key <= '9') {

        if (input=="0") input=String(key);

        else input+=key;

      }

      else if (key=='.' && input.indexOf('.')==-1) input+=".";

      else if (key=='<') {

        if (input.length()>0) input.remove(input.length()-1);

        if (input=="") input="0";

      }

      else if (key=='C') input="0";

    }


    // Draw keypad

    display.clearDisplay();

    display.setCursor(0,0); display.println("Enter Value");

    display.setCursor(0,12); display.println(input);


    for (int r=0;r<4;r++){

      for(int c=0;c<4;c++){

        if(keys[r][c]==' ') continue;

        int x=96+c*8, y=24+r*10;

        bool sel=(r==row && c==col);

        if(sel){ display.fillRect(x-2,y-1,12,10,SSD1306_WHITE); display.setTextColor(SSD1306_BLACK);}

        else display.setTextColor(SSD1306_WHITE);

        display.setCursor(x,y); display.print(keys[r][c]);

      }

    }

    display.display();

    delay(50);

  }

  waitRelease(BACK_BTN);

  return input;

}

// BMI


void runBMI() {

  int weight = 60;   // default weight (kg)

  int height = 170;  // default height (cm)

  bool onWeight = true; // true = adjusting weight, false = height

  bool showResult = false;

  float bmi = 0.0;


  unsigned long lastMove = 0; 

  const int HOLD_DELAY = 80; // ms between scroll steps


  while (!backPressed()) {

    unsigned long now = millis();


    // --- Switch between weight/height with Left/Right ---

    if (!showResult) {

      if (joyMovedLeft(lastMove) || joyMovedRight(lastMove)) {

        onWeight = !onWeight;

      }

    }


    // --- Scroll Up/Down ---

    int yVal = joyY();

    if (!showResult && now - lastMove > HOLD_DELAY) {

      if (yVal < (JOY_CENTER - JOY_DEADZONE)) { // scroll up

        if (onWeight && weight < 200) weight++;

        else if (!onWeight && height < 200) height++;

        lastMove = now;

      }

      else if (yVal > (JOY_CENTER + JOY_DEADZONE)) { // scroll down

        if (onWeight && weight > 1) weight--;

        else if (!onWeight && height > 1) height--;

        lastMove = now;

      }

    }


    // --- Press joystick button to calculate ---

    if (joyPressed()) {

      waitRelease(JOY_BTN);

      float h_m = height / 100.0;

      bmi = weight / (h_m * h_m);

      showResult = true;

    }


    // --- Draw screen ---

    display.clearDisplay();

    display.setTextSize(1);

    display.setTextColor(SSD1306_WHITE);

    display.setCursor(0, 0);

    display.println("BMI Calculator");

    display.drawFastHLine(0, 8, 128, SSD1306_WHITE);


    if (!showResult) {

      display.setCursor(0, 16);

      if (onWeight) display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

      display.print("Weight: ");

      display.print(weight);

      display.println(" kg");

      display.setTextColor(SSD1306_WHITE);


      display.setCursor(0, 28);

      if (!onWeight) display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

      display.print("Height: ");

      display.print(height);

      display.println(" cm");

      display.setTextColor(SSD1306_WHITE);


      display.setCursor(0, 44);

      display.println("Press = Calculate");

    } else {

      display.setTextSize(2);

      display.setCursor(0, 16);

      display.print("BMI: ");

      display.print(bmi, 1);


      display.setTextSize(1);

      display.setCursor(0, 40);

      if (bmi < 18.5) display.print("Underweight");

      else if (bmi < 25) display.print("Normal");

      else if (bmi < 30) display.print("Overweight");

      else display.print("Obese");


      display.setCursor(0, 56);

      display.print("Press = Recalc");

    }


    display.display();

    delay(20);

  }

  waitRelease(BACK_BTN);

}


// timer


// ==================== TIMER APP ====================

void runTimer() {

  const char* options[] = {"10 sec", "5 min", "10 min", "30 min"};

  unsigned long durations[] = {

    10 * 1000UL,       // 10 seconds

    5 * 60 * 1000UL,   // 5 minutes

    10 * 60 * 1000UL,  // 10 minutes

    30 * 60 * 1000UL   // 30 minutes

  };

  int totalOptions = 4;

  int selection = 0;

  unsigned long gateTs = 0;


  // --- Select Duration ---

  while (!backPressed()) {

    if (joyMovedUp(gateTs)) {

      selection = (selection - 1 + totalOptions) % totalOptions;

    }

    if (joyMovedDown(gateTs)) {

      selection = (selection + 1) % totalOptions;

    }

    if (joyPressed()) {

      waitRelease(JOY_BTN);

      break; // Start timer

    }


    display.clearDisplay();

    display.setTextSize(1);

    display.setCursor(0, 0);

    display.println("Select Timer");

    display.drawFastHLine(0, 10, 128, SSD1306_WHITE);


    for (int i = 0; i < totalOptions; i++) {

      display.setCursor(0, 16 + i * 10);

      if (i == selection) {

        display.setTextColor(SSD1306_BLACK, SSD1306_WHITE);

      } else {

        display.setTextColor(SSD1306_WHITE);

      }

      display.println(options[i]);

    }


    display.setTextColor(SSD1306_WHITE);

    display.display();

    delay(50);

  }

  if (backPressed()) { waitRelease(BACK_BTN); return; }


  // --- Countdown ---

  unsigned long duration = durations[selection];

  unsigned long endTime = millis() + duration;


  while (!backPressed()) {

    unsigned long remaining = (endTime > millis()) ? (endTime - millis()) : 0;


    display.clearDisplay();

    display.setTextSize(1);

    display.setCursor(0, 0);

    display.println("Timer Running");


    // Convert ms -> min:sec

    unsigned long totalSec = remaining / 1000;

    unsigned int mins = totalSec / 60;

    unsigned int secs = totalSec % 60;


    display.setTextSize(3);

    display.setCursor(10, 28);

    if (mins < 10) display.print("0");

    display.print(mins);

    display.print(":");

    if (secs < 10) display.print("0");

    display.print(secs);


    display.display();


    if (remaining == 0) break;

    delay(200);

  }


  // --- Buzzer rings continuously ---

  pinMode(BUZZER_PIN, OUTPUT);

  while (!backPressed()) {

    digitalWrite(BUZZER_PIN, HIGH);

    delay(200);

    digitalWrite(BUZZER_PIN, LOW);

    delay(200);

  }

  digitalWrite(BUZZER_PIN, LOW);

  waitRelease(BACK_BTN);

    }


//

// -------------------------------------------------------------------------------------------------------------------------------

// --------


  

    // Player spaceship (10x10) → stored as 2 bytes per row

const unsigned char PROGMEM playerShip[] = {

  0b00000110, 0b00,

  0b00001111, 0b00,

  0b00011111, 0b10,

  0b00111111, 0b11,

  0b01111111, 0b11,

  0b11111111, 0b11,

  0b01111111, 0b11,

  0b00111111, 0b11,

  0b00011111, 0b10,

  0b00001111, 0b00

};



// Enemy UFO (8x6)


 const unsigned char PROGMEM enemyShip[] = {

  0b00111100,

  0b01111110,

  0b11111111,

  0b11011011,

  0b11111111,

  0b01111110

};


// ================== GAME VARIABLES ==================

int playerY = SCREEN_HEIGHT / 2;

int bulletX = -1, bulletY = -1;

bool bulletActive = false;


#define NUM_ENEMIES 5

int enemyX[NUM_ENEMIES];

int enemyY[NUM_ENEMIES];

bool enemyActive[NUM_ENEMIES];

int enemyShakeDir[NUM_ENEMIES]; // for shaking effect


int score = 0;

int lives = 3;


// Stars

#define NUM_STARS 20

int starX[NUM_STARS];

int starY[NUM_STARS];


// ================== HELPER FUNCTIONS ==================

void initStars() {

  for (int i = 0; i < NUM_STARS; i++) {

    starX[i] = random(SCREEN_WIDTH);

    starY[i] = random(SCREEN_HEIGHT);

  }

}


void resetEnemy(int i) {

  enemyX[i] = SCREEN_WIDTH - 10;

  enemyY[i] = random(0, SCREEN_HEIGHT - 8);

  enemyActive[i] = true;

  enemyShakeDir[i] = random(0, 2) ? 1 : -1;

}


// ================== MAIN APP FUNCTION ==================

void runSpaceShooter() {

  // Game Initialization

  score = 0;

  lives = 3;

  playerY = SCREEN_HEIGHT / 2;

  bulletActive = false;


  for (int i = 0; i < NUM_ENEMIES; i++) {

    resetEnemy(i);

  }

  initStars();


  // ================== MAIN LOOP ==================

  while (!backPressed()) {

    display.clearDisplay();


    // ---- Stars Background ----

    for (int i = 0; i < NUM_STARS; i++) {

      display.drawPixel(starX[i], starY[i], SSD1306_WHITE);

      starX[i]--; // Move star to the left

      if (starX[i] < 0) {

        starX[i] = SCREEN_WIDTH - 1;

        starY[i] = random(SCREEN_HEIGHT);

      }

    }


    // ---- Player Movement ----

    int yVal = joyY();

    if (yVal < (JOY_CENTER - JOY_DEADZONE) && playerY > 0) playerY -= 2;

    if (yVal > (JOY_CENTER + JOY_DEADZONE) && playerY < SCREEN_HEIGHT - 10) playerY += 2;


    // ---- Shooting ----

    if (joyPressed() && !bulletActive) {

      bulletActive = true;

      bulletX = 12; // Start bullet in front of the ship

      bulletY = playerY + 4; // Align with ship's center

    }


    if (bulletActive) {

      display.drawLine(bulletX, bulletY, bulletX + 3, bulletY, SSD1306_WHITE);

      bulletX += 3; // Bullet speed

      if (bulletX > SCREEN_WIDTH) bulletActive = false;

    }


    // ---- Enemies ----

    for (int i = 0; i < NUM_ENEMIES; i++) {

      if (enemyActive[i]) {

        // Draw UFO

        display.drawBitmap(enemyX[i], enemyY[i], enemyShip, 8, 6, SSD1306_WHITE);


        // Movement (Shake and advance)

        enemyX[i] -= 1;

        enemyY[i] += enemyShakeDir[i];

        if (enemyY[i] <= 0 || enemyY[i] >= SCREEN_HEIGHT - 6) {

          enemyShakeDir[i] *= -1; // Reverse vertical direction at edges

        }


        // Reset if enemy goes off-screen

        if (enemyX[i] < -8) {

          resetEnemy(i);

          lives--;

          if (lives <= 0) {

            goto game_over_shooter; // Exit to game over screen

          }

        }


        // Bullet collision detection

        if (bulletActive && bulletX >= enemyX[i] && bulletX <= enemyX[i] + 8 &&

            bulletY >= enemyY[i] && bulletY <= enemyY[i] + 6) {

          bulletActive = false;

          resetEnemy(i);

          score++;

        }

      }

    }


    // ---- Player ----

    display.drawBitmap(0, playerY, playerShip, 10, 10, SSD1306_WHITE);


    // ---- HUD (Heads-Up Display) ----

    display.setTextSize(1);

    display.setCursor(60, 0);

    display.print("S:");

    display.print(score);

    display.setCursor(100, 0);

    display.print("L:");

    display.print(lives);


    display.display();

    delay(30); // Game speed

  }


  waitRelease(BACK_BTN);

  return;


// Game Over screen

game_over_shooter:

  display.clearDisplay();

  display.setTextSize(2);

  display.setCursor(16, 14);

  display.print(F("GAME OVER"));

  display.setTextSize(1);

  display.setCursor(22, 38);

  display.print(F("Score: "));

  display.print(score);

  display.display();

  

  delay(2000); // Show score for 2 seconds

  

  display.setCursor(10, 50);

  display.print(F("Press BACK to exit"));

  display.display();


  while (!backPressed()) {

      delay(10); // Wait for back button press

  }

  waitRelease(BACK_BTN);

}
// ---
// Sci Calculator Application
// This function handles the logic for the scientific calculator,
// allowing for power, square root, and decimal number calculations.
// It uses the joystick for navigation and selection.

// allowing for power, square root, and decimal number calculations.
// It uses the joystick for navigation and selection.
// ---
void runSciCalculator() {
  // Keypad layout for the scientific calculator
  // Includes numbers 0-9, decimal point, power, and square root symbols.
  // The first row is for the display and result.
  const char keys[4][5] = {
    {'1', '2', '3', '^', ' '},
    {'4', '5', '6', '.', ' '},
    {'7', '8', '9', 'V', '<'}, // V = Square Root, < = Backspace
    {'0', 'C', '=', ' ', ' '}
  };

  int row = 0, col = 0; // Cursor position on the virtual keypad
  unsigned long gateTs = 0; // Timestamp for joystick navigation debouncing
  String currentInput = ""; // String to hold the current number being entered
  String baseString = ""; // Stores the base number for the power calculation
  String exponentString = ""; // Stores the exponent for the power calculation
  bool calculatingPower = false; // Flag to indicate if we are entering the exponent
  double result = 0.0; // The final calculated result
  
  // Flag to check if the result is currently displayed
  bool showedResult = false; 

  while (!backPressed()) { // Loop until the back button is pressed
    // Handle joystick navigation for keypad cursor
    if (joyMovedLeft(gateTs)) col = (col + 4) % 5;
    if (joyMovedRight(gateTs)) col = (col + 1) % 5;
    if (joyMovedUp(gateTs)) row = (row + 3) % 4;
    if (joyMovedDown(gateTs)) row = (row + 1) % 4;

    if (joyPressed()) { // If the joystick button is pressed
      waitRelease(JOY_BTN); // Wait for the button to be released
      char key = keys[row][col]; // Get the selected key

      // Handle different key actions
      if (key >= '0' && key <= '9') { // Digit keys
        if (showedResult) {
          currentInput = "";
          baseString = "";
          exponentString = "";
          showedResult = false;
        }
        currentInput += key;
      } else if (key == '.') { // Decimal point
        if (showedResult) {
          currentInput = "0.";
          showedResult = false;
        } else if (currentInput.indexOf('.') < 0) {
          currentInput += '.';
        }
      } else if (key == '^') { // Power symbol
        if (currentInput.length() > 0 && !calculatingPower) {
          baseString = currentInput;
          currentInput = "";
          calculatingPower = true;
        }
      } else if (key == 'V') { // Square Root symbol
        if (currentInput.length() > 0) {
          double val = currentInput.toDouble();
          if (val >= 0) {
            result = sqrt(val);
            currentInput = String(result, 4);
            showedResult = true;
          } else {
            currentInput = "Error";
            showedResult = true;
          }
        }
      } else if (key == '=') { // Equals button
        if (calculatingPower && currentInput.length() > 0) {
          exponentString = currentInput;
          double base = baseString.toDouble();
          double exponent = exponentString.toDouble();
          result = pow(base, exponent);
          currentInput = String(result, 4);
          calculatingPower = false;
          showedResult = true;
        }
      } else if (key == '<') { // Backspace
        if (currentInput.length() > 0) {
          currentInput.remove(currentInput.length() - 1);
        } else if (calculatingPower) {
          currentInput = exponentString;
          exponentString = "";
          calculatingPower = false;
        } else if (baseString.length() > 0) {
          currentInput = baseString;
          baseString = "";
        }
      } else if (key == 'C') { // Clear
        currentInput = "";
        baseString = "";
        exponentString = "";
        calculatingPower = false;
        result = 0.0;
        showedResult = false;
      }
    }

    // Clear display for redraw
    display.clearDisplay(); 

    // Draw display area border
    display.drawRect(0, 0, 128, 20, SSD1306_WHITE); 

    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(2, 2);

    // Display the current input string or the result
    if (calculatingPower) {
      display.print(baseString);
      display.print("^");
      display.setCursor(2, 12);
      display.print(currentInput);
    } else {
      if (showedResult) {
        display.print("Result: ");
        display.print(currentInput);
      } else {
        display.print(currentInput);
      }
    }
    
    // Draw virtual keypad
    display.setTextSize(1);
    for (int r = 0; r < 4; r++) {
      for (int c = 0; c < 5; c++) {
        if (keys[r][c] == ' ') continue; // Skip empty key

        int x = c * 25 + 2; // X position for key
        int y = 22 + r * 10; // Y position for key
        bool sel = (r == row && c == col); // Check if current key is selected

        if (sel) {
          display.fillRect(x, y, 23, 9, SSD1306_WHITE);
          display.setTextColor(SSD1306_BLACK); // Highlight selected
        } else {
          display.setTextColor(SSD1306_WHITE); // Normal color
        }

        display.setCursor(x + 8, y + 1);
        
        // Use special characters for power and square root
        if (keys[r][c] == 'V') {
          display.print(F("SQRT"));
        } else if (keys[r][c] == '^') {
          display.print(F("PWR"));
        } else if (keys[r][c] == '<') {
          display.print(F("BS"));
        } else {
          display.print(keys[r][c]); // Print key text
        }
      }
    }

    display.display(); // Update display
    delay(10); // Small delay
  }

  waitRelease(BACK_BTN);
}

// ===============================================================================================
// =================================== ELEMENTS APP ==============================================
// ===============================================================================================

// Define a structure to hold element data
struct Element {
  const char* symbol;
  const char* name;
  int atomicNumber;
  float massNumber;
};

// Data for the first 20 elements, stored in PROGMEM to save RAM
const Element elements[20] PROGMEM = {
  {"H", "Hydrogen", 1, 1.008}, {"He", "Helium", 2, 4.0026},
  {"Li", "Lithium", 3, 6.94}, {"Be", "Beryllium", 4, 9.0122},
  {"B", "Boron", 5, 10.81}, {"C", "Carbon", 6, 12.011},
  {"N", "Nitrogen", 7, 14.007}, {"O", "Oxygen", 8, 15.999},
  {"F", "Fluorine", 9, 18.998}, {"Ne", "Neon", 10, 20.180},
  {"Na", "Sodium", 11, 22.990}, {"Mg", "Magnesium", 12, 24.305},
  {"Al", "Aluminium", 13, 26.982}, {"Si", "Silicon", 14, 28.085},
  {"P", "Phosphorus", 15, 30.974}, {"S", "Sulfur", 16, 32.06},
  {"Cl", "Chlorine", 17, 35.45}, {"Ar", "Argon", 18, 39.948},
  {"K", "Potassium", 19, 39.098}, {"Ca", "Calcium", 20, 40.078}
};

void runElements() {
  int selected = 0;       // Index of the currently selected element
  bool detailMode = false;  // false = grid view, true = detail view
  unsigned long gateTs = 0; // Timestamp for joystick debouncing

  while (true) {
    // --- INPUT HANDLING ---
    
    // If in detail mode, pressing BACK or JOY_BTN returns to the grid
    if (detailMode) {
      if (backPressed() || joyPressed()) {
        detailMode = false;
        // Wait for the button to be released to prevent immediate re-entry
        waitRelease(backPressed() ? BACK_BTN : JOY_BTN);
      }
    } 
    // If in grid mode, handle navigation and selection
    else {
      // Exit the app if the back button is pressed from the grid view
      if (backPressed()) {
        break; 
      }
      
      // Navigate the grid with the joystick
      if (joyMovedLeft(gateTs)) { if (selected % 5 > 0) selected--; }
      if (joyMovedRight(gateTs)) { if (selected % 5 < 4) selected++; }
      if (joyMovedUp(gateTs)) { if (selected >= 5) selected -= 5; }
      if (joyMovedDown(gateTs)) { if (selected < 15) selected += 5; }

      // Pressing the joystick button enters detail mode
      if (joyPressed()) {
        detailMode = true;
        waitRelease(JOY_BTN);
      }
    }

    // --- DRAWING ---
    display.clearDisplay();

    if (detailMode) {
      // Draw the detailed view for the selected element
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);
      display.setCursor(0, 0);
      display.print(elements[selected].symbol);
      display.print(" - ");
      display.println(elements[selected].name);
      display.drawFastHLine(0, 10, 128, SSD1306_WHITE);
      
      display.setCursor(0, 16);
      display.print("Atomic No: ");
      display.println(elements[selected].atomicNumber);

      display.setCursor(0, 28);
      display.print("Mass No: ");
      display.println(elements[selected].massNumber, 3);
      
      display.setCursor(0, 52);
      display.print("Press BACK to return");

    } else {
      // Draw the 5x4 grid of element symbols
      display.setTextSize(1);
      display.setTextColor(SSD1306_WHITE);

      int cols = 5;
      int cellW = 24, cellH = 14;

      for (int i = 0; i < 20; i++) {
        int col = i % cols;
        int row = i / cols;
        int x = col * cellW + 4;
        int y = row * cellH + 4;

        // Highlight the selected element
        if (i == selected) {
          display.fillRect(x - 4, y - 4, cellW, cellH, SSD1306_WHITE);
          display.setTextColor(SSD1306_BLACK);
        } else {
          display.setTextColor(SSD1306_WHITE);
        }
        
        display.setCursor(x, y);
        display.print(elements[i].symbol);
      }
    }
    
    display.display();
    delay(50); // Small delay for refresh rate
  }

  waitRelease(BACK_BTN); // Wait for back button release before exiting
}

// --- Helper function to display "App Not Found" message ---
void appNotFound() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 20);
  display.println("App Not Found");
  display.setCursor(0, 40);
  display.println("Press BACK to return");
  display.display();
  while(!backPressed()) {
    delay(50);
  }
  waitRelease(BACK_BTN);
}

// --- Helper function to launch apps from the command prompt ---
void runAppFromCommand(String name) {
  name.toLowerCase();

  if (name == "calculator") runCalculator();
  else if (name == "stopwatch") runStopwatch();
  else if (name == "alarm") runAlarm();
  else if (name == "snake") runSnake();
  else if (name == "distance") runDistance();
  else if (name == "temperature") runTemperature();
  else if (name == "sunlight") runSunlight();
  else if (name == "pong") runPong();
  else if (name == "wifi scanner" || name == "wifi") runWifiScanner();
  else if (name == "notes") runNotesApp();
  else if (name == "dice roller" || name == "dice") runDice();
  else if (name == "paint") runPaint();
  else if (name == "unit convetor" || name == "convert") runDistanceConverter();
  else if (name == "bmi") runBMI();
  else if (name == "timer") runTimer();
  else if (name == "spaceshooter" || name == "space") runSpaceShooter();
  else appNotFound();
}

// ================= COMMAND PROMPT ==================
void runCommandPrompt() {
  // virtual keyboard
  String keyboardUpper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  String keyboardLower = "abcdefghijklmnopqrstuvwxyz <"; // Includes space and backspace
  int cursorIndex = 0;
  bool isUpper = true;

  String inputText = "";
  unsigned long pressStart = 0;
  unsigned long gateTs = 0;

  while (!backPressed()) {
    // navigate keyboard with debounce
    if (joyMovedRight(gateTs)) {
        cursorIndex = min((isUpper ? (int)keyboardUpper.length() : (int)keyboardLower.length()) - 1, cursorIndex + 1);
    } else if (joyMovedLeft(gateTs)) {
        cursorIndex = max(0, cursorIndex - 1);
    }

    // toggle case with debounce (UP only)
    if (joyMovedUp(gateTs)) {
        isUpper = !isUpper;
        // Reset cursor if it's out of bounds after switching case
        cursorIndex = min(cursorIndex, (isUpper ? (int)keyboardUpper.length() : (int)keyboardLower.length()) - 1);
    }

    // button press logic
    if (joyPressed()) {
      if (pressStart == 0) {
        pressStart = millis(); // start timer
      }
    } else {
      if (pressStart != 0) {
        unsigned long pressTime = millis() - pressStart;
        if (pressTime < 2000) {
          // --- Short press: type character ---
          char c;
          if (isUpper) {
              c = keyboardUpper[cursorIndex];
              inputText += c;
          } else {
              c = keyboardLower[cursorIndex];
              if (c == '<') { // Handle backspace
                  if (inputText.length() > 0) {
                      inputText.remove(inputText.length() - 1);
                  }
              } else { // Handle letters and space
                  inputText += c;
              }
          }
        } else {
          // --- Long press (2s): run the app ---
          runAppFromCommand(inputText);
          // After returning from an app, clear the input text for the next command
          inputText = "";
        }
        pressStart = 0; // Reset timer after action
      }
    }

    // draw prompt on OLED display
    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);

    // Display the input text
    display.setCursor(0,0);
    display.print("> ");
    // Truncate if too long for the screen
    if (inputText.length() > 19) {
        display.print("..." + inputText.substring(inputText.length() - 16));
    } else {
        display.print(inputText);
    }

    // Display the currently selected key
    display.setCursor(0,20);
    display.print("Key: ");
    char selectedChar = isUpper ? keyboardUpper[cursorIndex] : keyboardLower[cursorIndex];
    
    // Display user-friendly names for special characters
    if (!isUpper) {
        if (selectedChar == '<') {
            display.print("Backspace");
        } else if (selectedChar == ' ') {
            display.print("Space");
        } else {
            display.print(selectedChar);
        }
    } else {
        display.print(selectedChar);
    }

    // Display instructions
    display.setCursor(0,50);
    display.print("Short=Type Long(2s)=Run");
    display.display();
    delay(10);
  }
  waitRelease(BACK_BTN);
}
